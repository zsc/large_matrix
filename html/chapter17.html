<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>第17章：隐式微分与双层优化</title>
    <link rel="stylesheet" href="./assets/style.css">
    <link rel="stylesheet" href="./assets/highlight.css">
    <script src="./assets/script.js" defer></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$']],
                displayMath: [['$$', '$$']],
                processEscapes: false,
                packages: {'[+]': ['noerrors']}
            },
            options: {
                ignoreHtmlClass: 'tex2jax_ignore',
                processHtmlClass: 'tex2jax_process'
            },
            loader: {
                load: ['[tex]/noerrors']
            }
        };
    </script>
</head>
<body>
    <div class="container">
        <nav id="sidebar" class="sidebar">
            <div class="sidebar-header">
                <h3>目录</h3>
                <button id="sidebar-toggle" class="sidebar-toggle">
                    <span></span>
                    <span></span>
                    <span></span>
                </button>
            </div>
            <ul class="nav-list"><li class=""><a href="./index.html">高级大规模矩阵计算教程</a></li><li class=""><a href="./chapter1.html">第1章：二阶优化的统一框架</a></li><li class=""><a href="./chapter2.html">第2章：Hessian近似的艺术</a></li><li class=""><a href="./chapter3.html">第3章：结构化二阶方法</a></li><li class=""><a href="./chapter4.html">第4章：增量Hessian计算</a></li><li class=""><a href="./chapter5.html">第5章：Schur补的妙用</a></li><li class=""><a href="./chapter6.html">第6章：矩阵Sketching技术</a></li><li class=""><a href="./chapter7.html">第7章：随机化数值线性代数</a></li><li class=""><a href="./chapter8.html">第8章：分布式矩阵运算</a></li><li class=""><a href="./chapter9.html">第9章：异步优化的数学基础</a></li><li class=""><a href="./chapter10.html">第10章：Riemannian优化基础</a></li><li class=""><a href="./chapter11.html">第11章：流形预条件技术</a></li><li class=""><a href="./chapter12.html">第12章：结构化矩阵的快速算法</a></li><li class=""><a href="./chapter13.html">第13章：动态低秩近似</a></li><li class=""><a href="./chapter14.html">第14章：大规模协同过滤的矩阵技术</a></li><li class=""><a href="./chapter15.html">第15章：实时推荐的增量矩阵方法</a></li><li class=""><a href="./chapter16.html">第16章：多模态推荐的张量分解</a></li><li class="active"><a href="./chapter17.html">第17章：隐式微分与双层优化</a></li><li class=""><a href="./chapter18.html">第18章：量子启发的矩阵算法</a></li><li class=""><a href="./chapter19.html">附录A：数值稳定性速查表</a></li><li class=""><a href="./chapter20.html">附录B：性能调优检查清单</a></li><li class=""><a href="./chapter21.html">附录C：常用矩阵恒等式</a></li><li class=""><a href="./CLAUDE.html">高级大规模矩阵计算教程项目说明</a></li><li class=""><a href="./README.html">高级大规模矩阵计算教程</a></li></ul>
        </nav>
        
        <main class="content">
            <article>
                <h1 id="17">第17章：隐式微分与双层优化</h1>
<p>隐式微分和双层优化是现代机器学习中日益重要的技术，特别是在元学习、超参数优化和神经架构搜索等领域。本章深入探讨如何高效计算通过隐式定义的函数的梯度，以及如何解决嵌套优化问题。我们将特别关注大规模问题中的计算挑战和数值稳定性问题。</p>
<h2 id="171">17.1 隐式函数定理的计算视角</h2>
<h3 id="_1">从经典定理到实际计算</h3>
<p>隐式函数定理告诉我们，当满足一定条件时，方程 $F(x, y) = 0$ 可以隐式定义 $y$ 作为 $x$ 的函数。在计算中，我们关心的是如何高效计算 $\frac{dy}{dx}$。</p>
<p>考虑平衡方程：
$$F(x, y^*(x)) = 0$$
其中 $y^*(x)$ 是给定 $x$ 时的隐式解。通过对两边求导，我们得到：
$$\frac{\partial F}{\partial x} + \frac{\partial F}{\partial y} \frac{dy^*}{dx} = 0$$
因此：
$$\frac{dy^*}{dx} = -\left(\frac{\partial F}{\partial y}\right)^{-1} \frac{\partial F}{\partial x}$$
<strong>关键洞察</strong>：我们不需要显式计算雅可比矩阵的逆，而是解线性系统：
$$\frac{\partial F}{\partial y} v = -\frac{\partial F}{\partial x}$$
<strong>实际计算中的考虑</strong>：</p>
<ol>
<li><strong>稀疏性利用</strong>：当 $\frac{\partial F}{\partial y}$ 稀疏时，使用专门的稀疏求解器（如SuperLU、UMFPACK）</li>
<li><strong>结构利用</strong>：块对角、带状矩阵等特殊结构可大幅加速</li>
<li><strong>精度控制</strong>：求解精度直接影响最终梯度精度，需要自适应调整</li>
</ol>
<p><strong>在深度学习中的应用场景</strong>：</p>
<ul>
<li><strong>平衡方程网络</strong>：神经ODE的稳态解</li>
<li><strong>能量最小化层</strong>：如OptNet中的二次规划层</li>
<li><strong>归一化层</strong>：BatchNorm、LayerNorm的隐式表示</li>
<li><strong>注意力机制</strong>：自注意力的固定点视角</li>
</ul>
<h3 id="_2">固定点迭代的隐式微分</h3>
<p>许多机器学习算法可以表示为固定点迭代：
$$y^* = T(x, y^*)$$
例如，在强化学习中的策略评估、图神经网络的消息传递等。</p>
<p>对于固定点 $y^*(x)$，隐式微分给出：
$$\frac{dy^*}{dx} = \left(I - \frac{\partial T}{\partial y}\right)^{-1} \frac{\partial T}{\partial x}$$
<strong>Neumann级数方法</strong>：当 $|\frac{\partial T}{\partial y}| &lt; 1$ 时，可以用级数展开：
$$\left(I - \frac{\partial T}{\partial y}\right)^{-1} = \sum_{k=0}^{\infty} \left(\frac{\partial T}{\partial y}\right)^k$$
这提供了一种迭代计算隐式梯度的方法。</p>
<p><strong>收敛性加速技术</strong>：</p>
<ol>
<li>
<p><strong>Chebyshev加速</strong>：利用谱信息优化收敛
$$y_{k+1} = \omega_k T(x, y_k) + (1-\omega_k)y_{k-1}$$
其中 $\omega_k$ 根据谱半径选择</p>
</li>
<li>
<p><strong>Anderson加速</strong>：利用历史信息构造更好的下一步
   - 存储最近m步的残差
   - 最小二乘组合获得加速</p>
</li>
<li>
<p><strong>动量方法</strong>：Polyak动量的固定点版本
$$z_{k+1} = T(x, y_k), \quad y_{k+1} = z_{k+1} + \beta(z_{k+1} - z_k)$$
<strong>实际案例：图神经网络的隐式层</strong></p>
</li>
</ol>
<p>考虑图注意力网络的固定点形式：
$$h_i^* = \sigma\left(\sum_{j \in \mathcal{N}(i)} \alpha_{ij}(h^*) W h_j^* + b\right)$$
其中 $\alpha_{ij}$ 是注意力权重。这定义了一个隐式的特征表示。</p>
<p><strong>计算策略</strong>：</p>
<ol>
<li>前向传播：用固定点迭代求解 $h^*$</li>
<li>反向传播：解线性系统计算梯度</li>
<li>内存优化：不存储中间迭代，需要时重计算</li>
</ol>
<h3 id="_3">矩阵方程的隐式解</h3>
<p>考虑Sylvester方程：
$$AX + XB = C$$
这在控制理论和图信号处理中经常出现。当参数化 $A(\theta), B(\theta), C(\theta)$ 时，我们需要计算 $\frac{dX}{d\theta}$。</p>
<p>利用vec算子和Kronecker积：
$$(I \otimes A + B^T \otimes I) \text{vec}(X) = \text{vec}(C)$$
隐式微分给出梯度计算的线性系统。</p>
<p><strong>高效求解策略</strong>：</p>
<ol>
<li>
<p><strong>Bartels-Stewart算法</strong>：
   - 将A和B化为Schur形式
   - 利用三角结构递归求解
   - 复杂度 $O(n^3)$，数值稳定</p>
</li>
<li>
<p><strong>Krylov子空间方法</strong>：
   - 对大规模问题，避免显式形成Kronecker积
   - 利用矩阵-向量积：$(I \otimes A + B^T \otimes I)v = \text{vec}(A\text{mat}(v) + \text{mat}(v)B)$
   - 适用于稀疏A、B</p>
</li>
<li>
<p><strong>低秩近似</strong>：
   当解接近低秩时：$X \approx UV^T$</p>
</li>
</ol>
<ul>
<li>交替方向法（ADI）</li>
<li>有理Krylov方法</li>
<li>截断奇异值分解</li>
</ul>
<p><strong>广义Sylvester方程</strong>：
$$\sum_{i=1}^k A_i X B_i = C$$
在张量分解、多线性系统中出现。求解更具挑战性，需要：</p>
<ul>
<li>张量Krylov方法</li>
<li>高阶奇异值分解</li>
<li>随机投影技术</li>
</ul>
<p><strong>在机器学习中的应用</strong>：</p>
<ol>
<li>
<p><strong>连续时间RNN</strong>：
   状态方程 $\dot{X} = AX + XB + f(X)$ 的稳态解</p>
</li>
<li>
<p><strong>图卷积的谱方法</strong>：
   图Laplacian的函数计算涉及矩阵方程</p>
</li>
<li>
<p><strong>矩阵补全的核范数正则化</strong>：
   优化子问题常归结为Sylvester方程</p>
</li>
</ol>
<p><strong>数值稳定性考虑</strong>：</p>
<ul>
<li>分离度 $\text{sep}(A, -B) = \min_{|X|_F=1} |AX + XB|_F$ 决定条件数</li>
<li>当分离度小时，需要正则化或迭代精化</li>
<li>对病态问题，考虑扰动分析和区间算法</li>
</ul>
<p><strong>研究方向</strong>：</p>
<ul>
<li>利用矩阵方程的特殊结构加速求解</li>
<li>低秩近似在大规模问题中的应用</li>
<li>随机化方法的误差分析</li>
<li>量子算法启发的新求解策略</li>
<li>非线性矩阵方程的隐式微分理论</li>
</ul>
<h2 id="172">17.2 大规模线性系统的高效求解</h2>
<h3 id="_4">迭代求解器的选择策略</h3>
<p>在隐式微分中，核心计算是求解形如 $Jv = r$ 的线性系统，其中 $J = \frac{\partial F}{\partial y}$。</p>
<p><strong>求解器选择决策树</strong>：</p>
<ol>
<li><strong>对称正定</strong>：共轭梯度法（CG）</li>
<li><strong>对称不定</strong>：MINRES</li>
<li><strong>非对称</strong>：GMRES或BiCGSTAB</li>
<li><strong>结构化</strong>：专用求解器（如FFT-based）</li>
</ol>
<p><strong>详细选择指南</strong>：</p>
<p>| 矩阵性质 | 推荐求解器 | 备选方案 | 适用场景 |</p>
<table>
<thead>
<tr>
<th>矩阵性质</th>
<th>推荐求解器</th>
<th>备选方案</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>对称正定</td>
<td>CG</td>
<td>PCG、Chebyshev</td>
<td>椭圆型PDE、正则化最小二乘</td>
</tr>
<tr>
<td>对称不定</td>
<td>MINRES</td>
<td>SYMMLQ、CR</td>
<td>鞍点问题、约束优化</td>
</tr>
<tr>
<td>非对称</td>
<td>GMRES(m)</td>
<td>BiCGSTAB、QMR</td>
<td>对流扩散、非对称预条件</td>
</tr>
<tr>
<td>正规矩阵</td>
<td>GMRES</td>
<td>Richardson</td>
<td>谱方法、特征值问题</td>
</tr>
<tr>
<td>块结构</td>
<td>Block-CG</td>
<td>Block-GMRES</td>
<td>多右端项、参数化问题</td>
</tr>
</tbody>
</table>
<p><strong>收敛性估计</strong>：</p>
<ul>
<li>CG收敛速率：$|e_k| \leq 2\left(\frac{\sqrt{\kappa}-1}{\sqrt{\kappa}+1}\right)^k |e_0|$</li>
<li>GMRES残差单调递减：$|r_k| = \min_{p \in \mathcal{P}_k} |p(A)r_0|$</li>
<li>BiCGSTAB：非单调但通常更快，适合非对称但谱接近实轴的问题</li>
</ul>
<p><strong>实际性能考虑</strong>：</p>
<ol>
<li>
<p><strong>内存需求</strong>：
   - CG/BiCGSTAB：$O(n)$ 存储
   - GMRES(m)：$O(mn)$ 存储，需要重启策略
   - MINRES：$O(n)$ 但需要更多向量</p>
</li>
<li>
<p><strong>计算成本</strong>：
   - 每步迭代：1-2次矩阵向量积
   - 预条件应用：通常是瓶颈
   - 正交化：GMRES中的主要开销</p>
</li>
<li>
<p><strong>并行性</strong>：
   - 矩阵向量积：易并行
   - 点积：全局通信瓶颈
   - 流水线CG：隐藏通信延迟</p>
</li>
</ol>
<h3 id="_5">预条件子在隐式微分中的作用</h3>
<p>良好的预条件子 $P \approx J$ 可以显著加速收敛：
$$P^{-1}Jv = P^{-1}r$$
<strong>预条件子设计原则</strong>：</p>
<ol>
<li>
<p><strong>不完全分解</strong>：ILU、不完全Cholesky
   - ILU(0)：保持稀疏模式
   - ILU(k)：允许k级填充
   - ILUT：基于阈值的丢弃</p>
</li>
<li>
<p><strong>代数多重网格</strong>：适用于PDE相关问题
   - 经典AMG：基于强连接
   - 聚合AMG：更鲁棒
   - SA-AMG：光滑聚合</p>
</li>
<li>
<p><strong>低秩更新</strong>：利用问题的增量特性
   - Woodbury公式：$(A + UV^T)^{-1} = A^{-1} - A^{-1}U(I + V^TA^{-1}U)^{-1}V^TA^{-1}$
   - 递归更新：保持有限历史</p>
</li>
<li>
<p><strong>物理启发</strong>：基于问题领域知识
   - 物理网格的多重网格
   - 频域的FFT预条件
   - 时域的隐式时间步进</p>
</li>
</ol>
<p><strong>高级预条件技术</strong>：</p>
<ol>
<li>
<p><strong>域分解方法</strong>：
   - 加性Schwarz：$P^{-1} = \sum_i R_i^T A_i^{-1} R_i$
   - 乘性Schwarz：更好收敛但串行
   - FETI/BDDC：平衡域分解</p>
</li>
<li>
<p><strong>多级预条件</strong>：
   <code>粗网格校正 + 细网格光滑
   V-cycle: 限制 → 粗网格求解 → 延拓
   W-cycle: 更鲁棒但计算量大</code></p>
</li>
<li>
<p><strong>谱预条件</strong>：
   - 多项式预条件：$P^{-1} = p(A)$
   - 有理函数预条件：更灵活
   - 循环矩阵近似：FFT加速</p>
</li>
</ol>
<p><strong>自适应预条件</strong>：
在优化过程中，雅可比矩阵会变化。可以使用：</p>
<ul>
<li>BFGS型更新维护预条件子</li>
<li>周期性重计算策略</li>
<li>基于收敛历史的自适应选择</li>
</ul>
<p><strong>实用策略</strong>：</p>
<div class="codehilite"><pre><span></span><code><span class="k">if</span><span class="w"> </span>迭代次数<span class="w"> </span><span class="o">&gt;</span><span class="w"> </span>阈值:
<span class="w">    </span><span class="k">if</span><span class="w"> </span>使用简单预条件:
<span class="w">        </span>升级到更复杂预条件
<span class="w">    </span><span class="nv">elif</span><span class="w"> </span>矩阵变化大:
<span class="w">        </span>重新计算预条件子
<span class="w">    </span><span class="k">else</span>:
<span class="w">        </span>增加预条件精度
</code></pre></div>

<h3 id="_6">近似求解的误差传播分析</h3>
<p>实践中，我们通常只能近似求解线性系统。设 $\tilde{v}$ 是近似解，满足：
$$|J\tilde{v} - r| \leq \epsilon |r|$$
<strong>误差传播定理</strong>：
隐式梯度的误差满足：
$$|\nabla_x L - \tilde{\nabla}_x L| \leq C \cdot \epsilon \cdot |\nabla_y L|$$
其中 $C$ 依赖于问题的条件数。</p>
<p><strong>精细化误差分析</strong>：</p>
<ol>
<li>
<p><strong>前向误差界</strong>：
$$\frac{|v - \tilde{v}|}{|v|} \leq \kappa(J) \frac{|J\tilde{v} - r|}{|r|}$$</p>
</li>
<li>
<p><strong>后向误差分析</strong>：
   $\tilde{v}$ 是扰动问题 $(J + \Delta J)\tilde{v} = r + \Delta r$ 的精确解</p>
</li>
<li>
<p><strong>概率误差估计</strong>：
   对随机化求解器：$\mathbb{E}[|v - \tilde{v}|^2] \leq f(\epsilon, \kappa)$</p>
</li>
</ol>
<p><strong>自适应精度控制</strong>：</p>
<ol>
<li>
<p><strong>基于目标的停止准则</strong>：
   <code>目标：|\nabla_x L|的相对误差 &lt; tol
   推导：线性求解器容差 = tol / (C * |\nabla_y L|)</code></p>
</li>
<li>
<p><strong>动态调整策略</strong>：
   - 初期：粗精度快速迭代
   - 中期：根据收敛速度调整
   - 后期：高精度确保准确性</p>
</li>
<li>
<p><strong>混合精度框架</strong>：
   - 低精度：探索阶段
   - 高精度：收敛阶段
   - 自动切换：基于进度指标</p>
</li>
</ol>
<p><strong>实用指南</strong>：</p>
<ul>
<li>根据最终梯度精度要求设置求解器容差</li>
<li>监控残差范数的下降曲线</li>
<li>使用温启动技术利用之前的解</li>
<li>实施早停避免过度求解</li>
</ul>
<p><strong>特殊结构的利用</strong>：</p>
<ol>
<li>
<p><strong>块对角主导</strong>：
   <code>J = [A  B]
       [C  D]
   其中A、D是主要块</code>
   使用块消去或近似Schur补</p>
</li>
<li>
<p><strong>低秩扰动</strong>：
   $J = J_0 + UV^T$，其中 $U, V \in \mathbb{R}^{n \times k}$, $k \ll n$</p>
</li>
</ol>
<ul>
<li>Sherman-Morrison-Woodbury公式</li>
<li>保持 $J_0^{-1}$ 或其近似</li>
</ul>
<ol start="3">
<li><strong>Kronecker结构</strong>：
   $J = A \otimes B + C \otimes D$</li>
</ol>
<ul>
<li>利用Kronecker积性质</li>
<li>降维到小规模Sylvester方程</li>
</ul>
<p><strong>研究方向</strong>：</p>
<ul>
<li>自适应精度控制算法</li>
<li>随机求解器的方差分析</li>
<li>混合精度策略的理论保证</li>
<li>机器学习加速的预条件子设计</li>
<li>量子线性求解器的经典模拟</li>
</ul>
<h2 id="173">17.3 自动微分的高级技巧</h2>
<h3 id="vs">前向模式vs反向模式的权衡</h3>
<p>在隐式微分中，选择合适的AD模式至关重要：</p>
<p><strong>前向模式优势场景</strong>：</p>
<ul>
<li>输入维度远小于输出维度</li>
<li>需要计算Hessian-vector积</li>
<li>实时/在线计算需求</li>
</ul>
<p><strong>反向模式优势场景</strong>：</p>
<ul>
<li>输出维度小（如标量损失）</li>
<li>内存充足</li>
<li>批处理场景</li>
</ul>
<p><strong>详细比较</strong>：</p>
<p>| 特性 | 前向模式 | 反向模式 |</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>前向模式</th>
<th>反向模式</th>
</tr>
</thead>
<tbody>
<tr>
<td>计算图遍历</td>
<td>一次前向</td>
<td>一次前向+一次反向</td>
</tr>
<tr>
<td>内存需求</td>
<td>$O(1)$</td>
<td>$O(n)$ 中间值存储</td>
</tr>
<tr>
<td>计算复杂度</td>
<td>$O(n_{\text{in}} \cdot \text{ops})$</td>
<td>$O(n_{\text{out}} \cdot \text{ops})$</td>
</tr>
<tr>
<td>适用于</td>
<td>$n_{\text{in}} \ll n_{\text{out}}$</td>
<td>$n_{\text{out}} \ll n_{\text{in}}$</td>
</tr>
<tr>
<td>并行性</td>
<td>输入维度并行</td>
<td>链式法则串行</td>
</tr>
</tbody>
</table>
<p><strong>混合策略</strong>：
对于隐式微分，常用的模式是：</p>
<ol>
<li>前向模式计算 $\frac{\partial F}{\partial x}$ 和 $\frac{\partial F}{\partial y}$</li>
<li>迭代求解线性系统</li>
<li>反向模式传播最终梯度</li>
</ol>
<p><strong>高级混合技术</strong>：</p>
<ol>
<li>
<p><strong>交叉模式（Cross-country）</strong>：
   - 部分前向、部分反向
   - 基于计算图结构优化
   - 最小化总体计算量</p>
</li>
<li>
<p><strong>向量雅可比积（VJP）vs 雅可比向量积（JVP）</strong>：
   <code>VJP: v^T J = 反向模式自然计算
   JVP: J v = 前向模式自然计算</code>
   选择取决于具体需求</p>
</li>
<li>
<p><strong>稀疏雅可比的高效计算</strong>：
   - 着色算法：将列分组以减少计算
   - 压缩感知：利用稀疏性
   - 随机探测：概率方法</p>
</li>
</ol>
<p><strong>实际案例：神经ODE的隐式微分</strong></p>
<p>考虑ODE：$\frac{dy}{dt} = f(y, t, \theta)$</p>
<p>伴随方法计算梯度：</p>
<ol>
<li>前向求解ODE得到轨迹</li>
<li>反向求解伴随ODE：$\frac{da}{dt} = -a^T \frac{\partial f}{\partial y}$</li>
<li>参数梯度：$\frac{dL}{d\theta} = \int a^T \frac{\partial f}{\partial \theta} dt$</li>
</ol>
<p>这是前向-反向混合的典型例子。</p>
<h3 id="_7">检查点技术与内存优化</h3>
<p>在深度模型中，存储所有中间激活值会消耗大量内存。检查点技术通过时间换空间：</p>
<p><strong>基本检查点策略</strong>：</p>
<ul>
<li>均匀检查点：每 $\sqrt{n}$ 层保存一次</li>
<li>自适应检查点：基于内存预算动态决定</li>
<li>混合精度检查点：关键层高精度，其他低精度</li>
</ul>
<p><strong>高级检查点算法</strong>：</p>
<ol>
<li>
<p><strong>最优检查点放置</strong>（Griewank &amp; Walther）：
   - 动态规划求解最优策略
   - 最小化重计算次数
   - 考虑不同层的计算成本</p>
</li>
<li>
<p><strong>递归二分策略</strong>：
   <code>checkpoint_recursive(start, end, budget):
       if budget == 0:
           重计算所有
       else:
           mid = (start + end) // 2
           保存mid处的激活值
           分配预算给两半</code></p>
</li>
<li>
<p><strong>选择性检查点</strong>：
   - 基于激活值大小
   - 基于重计算成本
   - 基于梯度重要性</p>
</li>
</ol>
<p><strong>隐式微分的特殊考虑</strong>：</p>
<ul>
<li>固定点迭代的中间状态可以重计算</li>
<li>利用问题的马尔可夫性质减少存储</li>
<li>异步检查点与计算重叠</li>
</ul>
<p><strong>内存高效的隐式微分实现</strong>：</p>
<ol>
<li>
<p><strong>就地操作</strong>：
   - 复用输入内存存储输出
   - 注意保持梯度计算正确性</p>
</li>
<li>
<p><strong>流式计算</strong>：
   - 分块处理大矩阵
   - 重叠计算与数据传输</p>
</li>
<li>
<p><strong>压缩存储</strong>：
   - 量化激活值
   - 稀疏表示
   - 低秩分解</p>
</li>
</ol>
<p><strong>案例：Transformer的内存优化</strong></p>
<p>自注意力的内存瓶颈：$O(n^2)$ 的注意力矩阵</p>
<p>优化策略：</p>
<ol>
<li><strong>FlashAttention</strong>：分块计算，融合kernel</li>
<li><strong>Reformer</strong>：LSH注意力，$O(n\log n)$</li>
<li><strong>Linformer</strong>：低秩投影，$O(nk)$</li>
</ol>
<h3 id="_8">混合精度计算策略</h3>
<p>在大规模问题中，混合精度可以显著提升性能：</p>
<p><strong>精度分配原则</strong>：</p>
<ol>
<li><strong>前向计算</strong>：FP16/BF16</li>
<li><strong>梯度累积</strong>：FP32</li>
<li><strong>线性求解器</strong>：根据条件数选择</li>
<li><strong>参数更新</strong>：FP32主权重</li>
</ol>
<p><strong>精度层次详解</strong>：</p>
<p>| 精度类型 | 位宽 | 动态范围 | 精度 | 使用场景 |</p>
<table>
<thead>
<tr>
<th>精度类型</th>
<th>位宽</th>
<th>动态范围</th>
<th>精度</th>
<th>使用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>FP32</td>
<td>32</td>
<td>$\pm 3.4 \times 10^{38}$</td>
<td>7位小数</td>
<td>标准训练</td>
</tr>
<tr>
<td>FP16</td>
<td>16</td>
<td>$\pm 65504$</td>
<td>3位小数</td>
<td>前向传播</td>
</tr>
<tr>
<td>BF16</td>
<td>16</td>
<td>$\pm 3.4 \times 10^{38}$</td>
<td>2位小数</td>
<td>更好的范围</td>
</tr>
<tr>
<td>INT8</td>
<td>8</td>
<td>$\pm 127$</td>
<td>整数</td>
<td>推理量化</td>
</tr>
</tbody>
</table>
<p><strong>数值稳定性保障</strong>：</p>
<ul>
<li>动态损失缩放</li>
<li>梯度裁剪</li>
<li>Kahan求和用于累积</li>
</ul>
<p><strong>高级混合精度技术</strong>：</p>
<ol>
<li><strong>自动混合精度（AMP）</strong>：
   ```python
   # 伪代码
   with autocast():
       output = model(input)  # FP16计算
       loss = loss_fn(output)  # FP32损失</li>
</ol>
<p># 梯度缩放
   scaled_loss = loss * scale_factor
   scaled_loss.backward()</p>
<p># 梯度反缩放和裁剪
   unscale_gradients()
   clip_gradients()
   optimizer.step()
   ```</p>
<ol start="2">
<li>
<p><strong>张量核心利用</strong>：
   - 确保矩阵维度是8的倍数
   - 使用合适的数据布局
   - 融合操作减少内存访问</p>
</li>
<li>
<p><strong>精度自适应算法</strong>：
   - 监控数值稳定性指标
   - 动态调整精度级别
   - 关键路径保持高精度</p>
</li>
</ol>
<p><strong>隐式微分的混合精度挑战</strong>：</p>
<ol>
<li>
<p><strong>条件数敏感性</strong>：
   - 线性系统求解对精度敏感
   - 可能需要迭代精化
   - 考虑使用双精度求解核心系统</p>
</li>
<li>
<p><strong>梯度累积误差</strong>：
   - 长序列的误差累积
   - 使用补偿求和技术
   - 周期性高精度校正</p>
</li>
<li>
<p><strong>收敛性保证</strong>：
   - 理论分析混合精度的收敛性
   - 实验验证不同精度组合
   - 建立精度选择准则</p>
</li>
</ol>
<p><strong>实践建议</strong>：</p>
<ol>
<li>
<p><strong>分层精度策略</strong>：
   <code>关键计算（线性求解）: FP32/FP64
   一般前向传播: FP16/BF16
   激活存储: INT8（带缩放）
   梯度通信: FP16（带误差反馈）</code></p>
</li>
<li>
<p><strong>硬件感知优化</strong>：
   - 利用特定硬件的混合精度能力
   - 考虑内存带宽vs计算能力
   - 优化数据移动模式</p>
</li>
<li>
<p><strong>调试和验证</strong>：
   - 对比全精度基准
   - 监控关键数值指标
   - 渐进式降低精度</p>
</li>
</ol>
<p><strong>研究方向</strong>：</p>
<ul>
<li>自动精度选择算法</li>
<li>硬件感知的AD优化</li>
<li>量化感知的隐式微分</li>
<li>新型数值格式（如Posit）在AD中的应用</li>
<li>概率数值方法与不确定性量化</li>
</ul>
<h2 id="174">17.4 双层优化的现代算法</h2>
<p>双层优化问题具有以下形式：
$$\min_{x} f(x, y^*(x)) \quad \text{s.t.} \quad y^*(x) = \arg\min_y g(x, y)$$
这在超参数优化、元学习、对抗训练等场景中广泛出现。</p>
<h3 id="_9">梯度展开法的收敛性分析</h3>
<p>梯度展开（Gradient Unrolling）通过展开内层优化的K步迭代来近似 $y^*(x)$：
$$y_0 = y_{\text{init}}, \quad y_{k+1} = y_k - \eta \nabla_y g(x, y_k)$$
<strong>收敛性定理</strong>：
假设 $g(x, \cdot)$ 是 $\mu$-强凸且 $L$-光滑的，则：
$$|y_K - y^*(x)| \leq (1 - \mu/L)^K |y_0 - y^*(x)|$$
<strong>偏差-方差权衡</strong>：</p>
<ul>
<li>小K：计算快但偏差大</li>
<li>大K：偏差小但计算慢且梯度可能消失</li>
</ul>
<p><strong>自适应展开策略</strong>：</p>
<ul>
<li>基于收敛检测的早停</li>
<li>动态调整步长 $\eta$</li>
<li>使用动量加速收敛</li>
</ul>
<h3 id="_10">隐式梯度方法的实现细节</h3>
<p>隐式梯度方法直接利用最优性条件：
$$\nabla_y g(x, y^*(x)) = 0$$
<strong>完整梯度公式</strong>：
$$\frac{d f}{d x} = \frac{\partial f}{\partial x} - \frac{\partial f}{\partial y} \left(\frac{\partial^2 g}{\partial y^2}\right)^{-1} \frac{\partial^2 g}{\partial x \partial y}$$
<strong>高效实现技巧</strong>：</p>
<ol>
<li><strong>向量-雅可比积</strong>：避免显式构造Hessian</li>
<li><strong>共轭梯度法</strong>：求解线性系统</li>
<li><strong>低秩近似</strong>：当Hessian近似低秩时</li>
</ol>
<p><strong>二阶锥规划视角</strong>：
某些双层问题可以重构为锥规划，利用成熟的求解器。</p>
<h3 id="_11">近似与精确方法的对比</h3>
<p><strong>计算复杂度对比</strong>：
| 方法 | 时间复杂度 | 空间复杂度 | 精度 |</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
<th>精度</th>
</tr>
</thead>
<tbody>
<tr>
<td>梯度展开(K步)</td>
<td>$O(K \cdot T_{\text{grad}})$</td>
<td>$O(K \cdot d)$</td>
<td>$O((1-\mu/L)^K)$</td>
</tr>
<tr>
<td>隐式梯度</td>
<td>$O(T_{\text{solve}} + T_{\text{opt}})$</td>
<td>$O(d^2)$</td>
<td>机器精度</td>
</tr>
<tr>
<td>一阶近似</td>
<td>$O(T_{\text{grad}})$</td>
<td>$O(d)$</td>
<td>$O(\eta)$</td>
</tr>
</tbody>
</table>
<p><strong>选择指南</strong>：</p>
<ul>
<li><strong>梯度展开</strong>：内层问题条件良好，需要在线学习</li>
<li><strong>隐式梯度</strong>：需要高精度，内层问题规模适中</li>
<li><strong>混合方法</strong>：温启动+隐式微分</li>
</ul>
<p><strong>研究方向</strong>：</p>
<ul>
<li>随机双层优化的方差减少技术</li>
<li>非凸内层问题的理论保证</li>
<li>分布式双层优化算法</li>
</ul>
<h2 id="175">17.5 元学习中的应用</h2>
<p>元学习旨在学习如何快速适应新任务，其核心是双层优化结构。</p>
<h3 id="maml">MAML算法的数学本质</h3>
<p>Model-Agnostic Meta-Learning (MAML) 解决：
$$\min_{\theta} \sum_{i=1}^N \mathcal{L}_i(\theta - \alpha \nabla \mathcal{L}_i(\theta))$$
这是一个双层优化问题，其中：</p>
<ul>
<li>外层：学习初始化参数 $\theta$</li>
<li>内层：任务特定的快速适应</li>
</ul>
<p><strong>梯度计算</strong>：
$$\nabla_{\theta} \mathcal{L}_i(\theta') = \nabla_{\theta'} \mathcal{L}_i(\theta') \cdot \left(I - \alpha \nabla^2 \mathcal{L}_i(\theta)\right)$$
<strong>一阶近似（FOMAML）</strong>：
忽略二阶项：$\nabla_{\theta} \mathcal{L}_i(\theta') \approx \nabla_{\theta'} \mathcal{L}_i(\theta')$</p>
<h3 id="_12">高阶导数的高效计算</h3>
<p>在K步适应的情况下，需要计算K阶导数。</p>
<p><strong>计算图优化</strong>：</p>
<ol>
<li><strong>前向累积</strong>：存储中间梯度</li>
<li><strong>反向传播</strong>：复用计算</li>
<li><strong>Hessian-vector积</strong>：避免显式Hessian</li>
</ol>
<p><strong>内存优化策略</strong>：</p>
<ul>
<li>梯度检查点</li>
<li>低秩分解</li>
<li>随机截断</li>
</ul>
<p><strong>数值稳定性</strong>：</p>
<ul>
<li>梯度裁剪</li>
<li>自适应学习率</li>
<li>正则化技术</li>
</ul>
<h3 id="_13">参数共享与正则化策略</h3>
<p><strong>层次化元学习</strong>：
不同层采用不同的适应策略：</p>
<ul>
<li>底层：固定或慢适应</li>
<li>高层：快速适应</li>
</ul>
<p><strong>正则化技术</strong>：</p>
<ol>
<li>
<p><strong>弹性权重巩固（EWC）</strong>：
$$\mathcal{L}_{\text{total}} = \mathcal{L}_{\text{task}} + \frac{\lambda}{2} \sum_i F_i (\theta_i - \theta^*_i)^2$$</p>
</li>
<li>
<p><strong>梯度对齐</strong>：
   鼓励不同任务的梯度方向一致</p>
</li>
</ol>
<p><strong>研究方向</strong>：</p>
<ul>
<li>任务相似度的自动发现</li>
<li>连续学习中的灾难性遗忘</li>
<li>元学习的泛化界</li>
</ul>
<h2 id="176">17.6 数值稳定性的挑战与对策</h2>
<p>隐式微分和双层优化在数值上具有挑战性，特别是在深度学习的规模上。</p>
<h3 id="_14">病态条件下的稳定化技术</h3>
<p>当 $\frac{\partial F}{\partial y}$ 接近奇异时，线性系统变得病态。</p>
<p><strong>正则化方法</strong>：</p>
<ol>
<li>
<p><strong>Tikhonov正则化</strong>：
$$\left(\frac{\partial F}{\partial y} + \epsilon I\right) v = -\frac{\partial F}{\partial x}$$</p>
</li>
<li>
<p><strong>截断SVD</strong>：
   丢弃小奇异值对应的分量</p>
</li>
<li>
<p><strong>迭代精化</strong>：
   使用高精度计算残差，低精度更新</p>
</li>
</ol>
<p><strong>自适应正则化</strong>：</p>
<ul>
<li>基于条件数估计选择 $\epsilon$</li>
<li>交叉验证选择最优正则化强度</li>
<li>贝叶斯方法自动确定</li>
</ul>
<h3 id="_15">梯度消失/爆炸的检测与缓解</h3>
<p><strong>检测指标</strong>：</p>
<ol>
<li><strong>梯度范数监控</strong>：$|\nabla L|$</li>
<li><strong>相对变化</strong>：$\frac{|\nabla L_t - \nabla L_{t-1}|}{|\nabla L_{t-1}|}$</li>
<li><strong>谱半径估计</strong>：幂迭代法</li>
</ol>
<p><strong>缓解策略</strong>：</p>
<ol>
<li>
<p><strong>梯度裁剪</strong>：
   - 全局范数裁剪
   - 逐元素裁剪
   - 自适应裁剪阈值</p>
</li>
<li>
<p><strong>重参数化</strong>：
   - 参数归一化
   - 谱归一化
   - 权重标准化</p>
</li>
<li>
<p><strong>架构设计</strong>：
   - 残差连接
   - 归一化层
   - 注意力机制</p>
</li>
</ol>
<h3 id="_16">鲁棒性设计原则</h3>
<p><strong>原则1：渐进式复杂度</strong>
从简单问题开始，逐步增加复杂度：</p>
<ul>
<li>小规模 → 大规模</li>
<li>低维 → 高维</li>
<li>凸 → 非凸</li>
</ul>
<p><strong>原则2：多尺度方法</strong>
不同尺度使用不同精度：</p>
<ul>
<li>粗网格：低精度快速收敛</li>
<li>细网格：高精度精确求解</li>
</ul>
<p><strong>原则3：冗余性设计</strong></p>
<ul>
<li>多种求解器备选</li>
<li>自动故障检测和恢复</li>
<li>结果验证机制</li>
</ul>
<p><strong>研究方向</strong>：</p>
<ul>
<li>自适应算法的理论分析</li>
<li>硬件错误的容错设计</li>
<li>概率数值方法的应用</li>
</ul>
<h2 id="_17">本章小结</h2>
<p>本章深入探讨了隐式微分和双层优化在大规模矩阵计算中的理论与实践。关键要点包括：</p>
<ol>
<li>
<p><strong>隐式函数定理的计算化</strong>：将抽象的数学定理转化为实际可计算的算法，核心是高效求解线性系统而非显式求逆</p>
</li>
<li>
<p><strong>线性求解器的选择艺术</strong>：根据矩阵性质（对称性、正定性、稀疏模式）选择合适的迭代求解器，预条件子设计至关重要</p>
</li>
<li>
<p><strong>自动微分的高级技巧</strong>：前向/反向模式的权衡、检查点技术、混合精度策略，都是大规模问题中的关键优化</p>
</li>
<li>
<p><strong>双层优化的两种范式</strong>：梯度展开提供了简单但近似的解法，隐式梯度提供了精确但计算密集的方案</p>
</li>
<li>
<p><strong>元学习的数学本质</strong>：MAML等算法本质上是特殊的双层优化问题，理解这一点有助于设计更好的算法</p>
</li>
<li>
<p><strong>数值稳定性的系统方法</strong>：从问题检测、算法设计到鲁棒性保证，需要全方位的考虑</p>
</li>
</ol>
<h2 id="_18">练习题</h2>
<h3 id="_19">基础题</h3>
<p><strong>习题17.1</strong> 考虑固定点方程 $x = \tanh(Wx + b)$，其中 $W \in \mathbb{R}^{n \times n}$，$b \in \mathbb{R}^n$。
a) 推导 $\frac{\partial x^*}{\partial b}$ 的表达式
b) 当 $|W|_2 &lt; 1$ 时，证明固定点唯一存在
c) 设计一个高效算法计算该导数</p>
<details>
<summary>提示</summary>
<p>利用隐式函数定理和 $\tanh'(x) = 1 - \tanh^2(x)$</p>
</details>
<details>
<summary>答案</summary>
<p>a) 设 $F(x,b) = x - \tanh(Wx + b) = 0$，则：
$$\frac{\partial x^*}{\partial b} = (I - \text{diag}(1-\tanh^2(Wx^*+b))W)^{-1}\text{diag}(1-\tanh^2(Wx^*+b))$$
b) 定义 $T(x) = \tanh(Wx + b)$，则 $|T(x) - T(y)| \leq |W|_2 |x - y|$，当 $|W|_2 &lt; 1$ 时为压缩映射</p>
<p>c) 使用共轭梯度法求解线性系统，利用矩阵结构只需矩阵-向量积</p>
</details>
<p><strong>习题17.2</strong> 在L-BFGS算法中存储m个向量对 $(s_i, y_i)$。若将L-BFGS近似用作预条件子，分析：
a) 预条件子应用一次的计算复杂度
b) 存储需求
c) 与完整BFGS相比的近似误差</p>
<details>
<summary>提示</summary>
<p>回顾L-BFGS的两循环递归算法</p>
</details>
<details>
<summary>答案</summary>
<p>a) $O(mn)$，其中n是问题维度，m是存储的向量对数
b) $O(mn)$ 存储空间
c) 误差主要来自丢弃的早期曲率信息，可以用谱分析量化</p>
</details>
<p><strong>习题17.3</strong> 考虑双层优化问题：
$$\min_x |Ax - b|^2 \quad \text{s.t.} \quad A = \arg\min_A |AX - Y|_F^2 + \lambda|A|_F^2$$
其中 $X, Y$ 是给定的数据矩阵。
a) 求解内层问题的闭式解
b) 计算外层目标对x的梯度
c) 这个问题在什么应用中会出现？</p>
<details>
<summary>提示</summary>
<p>内层是标准的岭回归问题</p>
</details>
<details>
<summary>答案</summary>
<p>a) $A^* = YX^T(XX^T + \lambda I)^{-1}$
b) 使用隐式微分，需要求解Sylvester方程
c) 在自适应线性系统辨识、元学习线性模型等场景</p>
</details>
<h3 id="_20">挑战题</h3>
<p><strong>习题17.4</strong> 设计一个自适应算法，在求解隐式微分的线性系统时自动选择合适的求解器和预条件子。算法应该：</p>
<ul>
<li>估计矩阵的条件数和谱性质</li>
<li>根据问题规模选择直接法或迭代法</li>
<li>动态调整求解精度</li>
</ul>
<details>
<summary>提示</summary>
<p>可以使用少量矩阵-向量积估计谱信息，考虑Gershgorin圆盘定理</p>
</details>
<details>
<summary>答案</summary>
<p>算法框架：</p>
<ol>
<li>用Lanczos迭代估计极值特征值</li>
<li>计算条件数估计，若 $\kappa &lt; 100$ 且 $n &lt; 1000$ 用直接法</li>
<li>否则用迭代法，根据对称性选择CG/GMRES</li>
<li>监控残差下降率，自适应调整预条件子</li>
</ol>
</details>
<p><strong>习题17.5</strong> 考虑神经网络中的归一化层可以看作隐式层：给定输入 $x$，输出 $y$ 满足 $\text{mean}(y) = 0$, $\text{var}(y) = 1$。
a) 将BatchNorm表示为隐式函数 $F(x,y) = 0$ 的形式
b) 推导反向传播公式，不使用自动微分
c) 分析数值稳定性，特别是当batch size很小时</p>
<details>
<summary>提示</summary>
<p>考虑约束优化的KKT条件</p>
</details>
<details>
<summary>答案</summary>
<p>这是一个约束优化问题，可以用Lagrange乘子法。关键是处理奇异情况（如所有输入相同时）。需要正则化技术保证数值稳定性。</p>
</details>
<p><strong>习题17.6</strong> 在联邦学习中，每个客户端解决局部优化问题，服务器聚合结果。将其建模为双层优化：
$$\min_{x_0} \sum_{i=1}^n f_i(x_i^*) \quad \text{s.t.} \quad x_i^* = \arg\min_{x_i} g_i(x_i) + \frac{\rho}{2}|x_i - x_0|^2$$
设计一个通信高效的算法求解，考虑：</p>
<ul>
<li>客户端计算能力异构</li>
<li>通信带宽限制</li>
<li>隐私保护需求</li>
</ul>
<details>
<summary>提示</summary>
<p>考虑ADMM框架和差分隐私</p>
</details>
<details>
<summary>答案</summary>
<p>可以使用异步ADMM，结合：</p>
<ol>
<li>压缩感知减少通信</li>
<li>局部SGD减少通信轮次</li>
<li>差分隐私噪声保护梯度</li>
<li>重要性采样处理异构性</li>
</ol>
</details>
<p><strong>习题17.7</strong> 研究如何将隐式微分扩展到非光滑优化。考虑问题：
$$y^*(x) = \arg\min_y f(x,y) + \lambda|y|_1$$</p>
<p>a) 当 $y^*$ 的某些分量恰好为0时，如何定义和计算导数？
b) 设计一个算法计算 $\frac{\partial y^*}{\partial x}$
c) 在什么条件下该导数是良定义的？</p>
<details>
<summary>提示</summary>
<p>考虑次微分和Moreau包络</p>
</details>
<details>
<summary>答案</summary>
<p>需要使用隐式函数定理的非光滑版本，关键是识别活跃集（非零分量）并在降维空间中应用光滑隐式函数定理。算法需要处理活跃集变化的情况。</p>
</details>
<p><strong>习题17.8</strong> 考虑一个"学习优化器"的元学习问题：我们想学习一个参数化的优化算法 $x_{k+1} = g_\theta(x_k, \nabla f(x_k))$，使其在一类函数上表现良好。</p>
<p>a) 将此建模为双层优化问题
b) 分析梯度计算的复杂度
c) 提出一个实用的近似算法
d) 这与传统优化器（如Adam）有何本质区别？</p>
<details>
<summary>提示</summary>
<p>考虑展开K步优化过程</p>
</details>
<details>
<summary>答案</summary>
<p>这需要通过K步优化轨迹反向传播，计算复杂度为 $O(K \cdot \text{cost}(\nabla f))$。可以使用截断反向传播或合成梯度降低复杂度。本质区别是数据驱动vs理论驱动。</p>
</details>
<h2 id="_21">常见陷阱与错误</h2>
<ol>
<li>
<p><strong>线性系统求解精度不足</strong>：隐式梯度对线性系统解的精度敏感，残差过大会导致梯度偏差累积</p>
</li>
<li>
<p><strong>忽略正则化的必要性</strong>：即使理论上矩阵可逆，数值上也可能接近奇异，需要适当正则化</p>
</li>
<li>
<p><strong>内存管理不当</strong>：在深度学习中，存储所有中间Jacobian会快速耗尽内存，需要精心设计计算图</p>
</li>
<li>
<p><strong>固定点不存在或不唯一</strong>：在非凸情况下，隐式函数可能无定义，需要额外处理</p>
</li>
<li>
<p><strong>梯度展开步数选择不当</strong>：太少导致偏差大，太多导致梯度消失和计算浪费</p>
</li>
<li>
<p><strong>混淆一阶和二阶方法</strong>：FOMAML等一阶近似在某些问题上效果很好，但不是万能的</p>
</li>
<li>
<p><strong>数值微分验证缺失</strong>：复杂的隐式微分实现容易出错，应该用有限差分验证</p>
</li>
<li>
<p><strong>并行化机会浪费</strong>：许多计算可以并行化（如不同任务的梯度），但串行实现会很慢</p>
</li>
</ol>
<h2 id="_22">最佳实践检查清单</h2>
<h3 id="_23">算法设计阶段</h3>
<ul>
<li>[ ] 问题是否真的需要隐式微分？是否有显式替代方案？</li>
<li>[ ] 内层问题的性质：凸性、光滑性、条件数？</li>
<li>[ ] 预期的问题规模和精度要求？</li>
<li>[ ] 是否需要二阶信息，还是一阶近似足够？</li>
</ul>
<h3 id="_24">实现阶段</h3>
<ul>
<li>[ ] 选择合适的线性求解器和预条件子</li>
<li>[ ] 实现数值稳定性保护（正则化、裁剪等）</li>
<li>[ ] 设计高效的内存管理策略</li>
<li>[ ] 利用问题结构（稀疏性、低秩性等）</li>
<li>[ ] 实现梯度检查和调试工具</li>
</ul>
<h3 id="_25">调优阶段</h3>
<ul>
<li>[ ] 监控关键数值指标（条件数、残差、梯度范数）</li>
<li>[ ] 根据问题特点调整算法参数</li>
<li>[ ] 平衡精度和效率的权衡</li>
<li>[ ] 考虑硬件特性优化（GPU、分布式）</li>
</ul>
<h3 id="_26">部署阶段</h3>
<ul>
<li>[ ] 鲁棒性测试：极端输入、数值边界情况</li>
<li>[ ] 性能基准测试和瓶颈分析</li>
<li>[ ] 故障恢复机制</li>
<li>[ ] 文档化数值稳定性假设和限制</li>
</ul>
            </article>
            
            <nav class="page-nav"><a href="./chapter16.html" class="nav-link prev">← 第16章：多模态推荐的张量分解</a><a href="./chapter18.html" class="nav-link next">第18章：量子启发的矩阵算法 →</a></nav>
        </main>
    </div>
</body>
</html>